% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/zxx.R
\name{cumfuns}
\alias{cumfuns}
\alias{cum_reset}
\alias{cum_na}
\alias{cumsum_na}
\alias{cumprod_na}
\alias{cummax_na}
\alias{cummin_na}
\title{Cumulative functions}
\usage{
cum_reset(x, value = 0L, FUN)

cum_na(x, FUN, useNA = TRUE)

cumsum_na(x, useNA = TRUE)

cumprod_na(x, useNA = TRUE)

cummax_na(x, useNA = TRUE)

cummin_na(x, useNA = TRUE)
}
\arguments{
\item{x}{a vector}

\item{value}{a value of \code{x} which signals the end of a group and
resets \code{FUN}}

\item{FUN}{function to apply to each group, usually one of
\code{\link{cumsum}}, \code{\link{cumprod}}, \code{\link{cummax}}, or
\code{\link{cummin}} but can be any function that returns a vector the
same length and type as the input (\emph{a la} \code{\link{ave}})}

\item{useNA}{logical; if \code{TRUE}, indices with \code{NA} will be
unchanged; if \code{FALSE}, the previous value is carried forward}
}
\value{
A vector having the same length as \code{x} with \code{FUN} applied to
each group defined by positions of \code{value}.
}
\description{
Reset a cumulative function when code{value} is encountered and versions
of \pkg{b}ase \link[=cumsum]{cumulative functions} that handle \code{NA}s.
}
\examples{
x <- 1:10
cum_reset(x, 5, cummin)
cum_reset(x, c(5, 8), cummin)

x[x \%\% 4 == 0] <- 0
cum_reset(x, FUN = cumsum)
cum_reset(x, FUN = sum)

set.seed(1)
data.frame(x = x <- rpois(15, 1),
           y = cum_reset(x, FUN = cumsum),
           z = cum_reset(x, 0, function(x) ave(x, FUN = sum)))


## x need not be numeric if FUN returns an appropriate type and length
cum_reset(letters[1:10], c('d','g'), function(x)
  letters[as.numeric(factor(x))])


## cum* functions to handle NA values
x <- 1:10
x[x \%\% 4 == 0] <- 0
na <- ifelse(x == 0, NA, x)

cumsum(x)
cum_na(x, cumsum)

cumsum(na)
cum_na(na, cumsum)

## shorthand
cumsum_na(na)
cumsum_na(na)


## like cum_reset, cum_na's FUN argument can be generalized if FUN
## returns the correct class and length of the input
FUN <- function(x) vector(class(x), length(x))
cum_na(na, FUN)

cumdiff <- function(x) Reduce(`-`, x, accumulate = TRUE)
cumdiff(x)
cumsum(c(x[1L], -x[-1L]))

cumdiff(na)
cumsum(c(na[1L], -na[-1L]))
cum_na(na, cumdiff)

}
\seealso{
\code{\link{cumsum}}; \code{\link{ave}}; \code{locf}
}
